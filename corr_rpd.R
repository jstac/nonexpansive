###########################################################################
#                                                                         #
#    RPD applied to correlated shock model, May 2006, John Stachurski     #
#                                                                         #
###########################################################################

######################### primitives ######################################

RHO = 0.9 # the discount rate
LAMBDA = 0.7 # carryover depreciation parameter
THETA = 0.3 # parameter in the shock process
ALPHA = 0.2 # utility parameter

U = function(c) return(c^ALPHA) # the utility function
# innovation is a + b W, where W is beta(5,5)
a = 1; b = 2
G = function(z) return(pbeta((z - a)/b, 5, 5)) # the cdf of innovation

######################## the grid #########################################

SHOCK_UB = a + b # upper bound of the innovation, since W <= 1 
SHOCK_LB = a # upper bound of the innovation, since W >= 0
K = 250 # number of elements in S-grid
J = 20 # number of elements in H-grid
S_UPPER = SHOCK_UB / (1 - LAMBDA) # upper bound of s
S_LOWER = SHOCK_LB # lower bound of s
# these next two steps set out a grid clustered around zero.  hist(X)
# will show you what it looks like
S = seq(S_LOWER^ALPHA, S_UPPER^ALPHA, length=K)
S = S^(1/ALPHA) 
H = seq(SHOCK_LB, SHOCK_UB, length=J)


######################## useful functions #################################

# returns a matrix P, where P[k,j] is prob that (s',h') in rectangle northeast
# of (S_k, H_j)
trans_prob = function(q, h) 
{ 
  m = (S - LAMBDA * q - THETA * h) / (1 - THETA)
  n = (H - THETA * h) / (1 - THETA)
  S = outer(n[-J], m[-K], pmax)
  I = outer(n[-1], m[-1], pmin)
  return( pmax(G(I) - G(S),0) )
}

# objective function (rhs of Bellman) given action, state and value function
ob = function(q, s, h, v)   
{ return( U(s - q) + RHO * ( sum( v[-J,-K] * trans_prob(q, h) ) ) )
}

# function to maximize ob() wrt q, given state and value function
compute_max = function(ss, hh, vv)  
{ if (ss == 0) r = ob(0, 0, hh, vv) 
  else 
    r = optimize(ob, c(0, ss), maximum=TRUE, tol=0.01, s=ss, h=hh, v=vv)[[2]]
  return( r )
}

# same, but computes argmax
compute_argmax = function(ss, hh, vv)  
{ if (ss == 0) r = 0
  else 
    r = optimize(ob, c(0, ss), maximum=TRUE, s=ss, h=hh, v=vv)[[1]]
  return( r )
}

########################## main loop ######################################

# step functions generated by iteration are stored as matrices

v = matrix(nrow = J, ncol = K)
for (j in 1:J)  v[j,] = U(S) # initial condition, a vector/step function
Tv = v  # just sets up a matrix of the right dimension 
n = 0

for (l in 1:40) { 
    n = n + 1; cat("starting loop", n, "\n")
    # first, calculate Tv
    for (j in 1:J) 
    { 
      for (k in 1:K)  Tv[j,k] = compute_max(S[k], H[j], v)
    }
    # now we have Tv check the sup norm deviation from v
    e = max( abs(Tv - v) ); print(e)
    v = Tv
}

###################### optimal policy ######################################

policy = matrix(nrow = J, ncol = K)
for (j in 1:J) for (k in 1:K)  policy[j,k] = compute_argmax(S[k], H[j], v)


########################## errors ##########################################

for (j in 1:J) for (k in 1:K) Tv[j,k] = ob(policy[j,k], S[k], H[j], v)
jump = matrix(nrow = (J - 1), ncol = (K - 1))
for (j in 1:(J-1)) for (k in 1:(K-1)) jump[j,k] = Tv[j+1,k+1] - Tv[j,k]
R = max( jump )
factor = 2 / (1 - RHO)
eb = factor * (RHO * e + R)
cat("\n\nError bound is", eb, "\n")
cat("R is", R, "\n")
cat("factor is", factor, "\n")
cat("number of loops was", n, "\n")
cat("relative error bound is", eb / v[1,1], "\n\n")






############################### plots #####################################

#par(pin=c(5.8,5.8))
#persp(H, S, policy,  theta = 20, phi = 20, scale = F, expand=1, shade=0.25, ticktype="detailed", d=2, xlab="", ylab="", zlab="", main="policy", nticks=3, lphi=20, ltheta=0)
