###########################################################################
#                                                                         #
#          Repeated Partial Discretization, May 2006, John Stachurski     #
#                                                                         #
###########################################################################

######################### primitives ######################################

RHO = 0.9 # the discount rate
LAMBDA = 0.7 # carryover depreciation parameter
ALPHA = 0.2 # utility parameter
TOL = 0.1 # tolerance in the FVI algorithm

U = function(c) return( c^ALPHA ) # the utility function
# shock is a + b W, where W is beta(5,5)
a = 1; b = 2
G = function(z) return( pbeta( (z - a)/b, 5, 5) ) # the cdf 

######################## the grid #########################################

SHOCK_UB = a + b # upper bound of the shock, since W <= 1 
SHOCK_LB = a # upper bound of the shock, since W >= 0
GRIDSIZE=50 # number of elements in the grid
XUPPER = SHOCK_UB / (1 - LAMBDA) # upper bound of state space
XLOWER = SHOCK_LB
# these next two steps set out a grid clustered around zero.  hist(X)
# will show you what it looks like
X = seq(XLOWER^ALPHA, XUPPER^ALPHA, length=GRIDSIZE)
X = X^(1/ALPHA) 


######################## useful functions #################################

# first is a function to evaluate transition probabilities.  let p_i(q) be prob
# that tomorrow's state is in [x_i,x_i+1) given carryover q. the next function
# takes q as an argument and returns the vector of p_i(q)'s. this vector has
# length GRIDSIZE - 1.  the following code is equivalent to setting up a for
# loop and evaluating G(x[i+1] - LAMBDA * q) - G(x[i] - LAMBDA * q)
# for each i, but much quicker. note that in the code, -1 (resp. -GRIDSIZE)
# drops off the first (resp. last) element of a vector
trans_prob = function(q) 
{ return( G(X - LAMBDA * q)[-1] - G(X - LAMBDA * q)[-GRIDSIZE] )
}

# objective function (rhs of Bellman) given action, state and value function
ob = function(q, x, v)   
{ return( U(x - q) + RHO * v[-GRIDSIZE] %*% trans_prob(q) )
}

# function to maximize ob() wrt q, given state and value function
compute_max = function(s, val)  
{ if (s == 0) r = ob(0, 0, val) 
  else 
    r = optimize(ob, c(0, s), maximum=TRUE, tol=0.001, x=s, v=val)[[2]]
  return( r )
}

# same, but computes argmax
compute_argmax = function(s, val)   
{ if (s == 0) r = 0
  else 
    r = optimize(ob, c(0, s), maximum=TRUE, x=s, v=val)[[1]]
  return( r )
}

########################## main loop ######################################

# step functions generated by iteration are stored as vectors, where the i-th
# element of the vector is the value of the function on [x_i,x_i+1). 

v = U(X) # initial condition, a vector/step function
Tv = numeric(GRIDSIZE) # Tv[i] will hold Tv(x_i)
n = 0

repeat 
{ n = n + 1; cat("starting loop", n, "\n")
  # first, calculate Tv(x_i) for each i
  for(i in 1:GRIDSIZE) Tv[i] = compute_max(X[i], v)
  # now we have Tv check the sup norm deviation from v
  e = max( abs(Tv - v) )
  v = Tv
  # terminate the loop when e falls below the tolerance
  if (e <= TOL) break
}

###################### optimal policy ######################################

policy = numeric()
for(i in 1:GRIDSIZE) policy[i] = compute_argmax(X[i], v) 
 
########################## errors ##########################################

for(i in 1:GRIDSIZE) Tv[i] = ob(policy[i], X[i], v) 

R = max(Tv[-1] - Tv[-GRIDSIZE])

eb = (2 / (1 - RHO)) * (RHO * e + R)
cat("error bound is", eb, "\n")
cat("number of loops was", n, "\n")

############################### plots #####################################

pdf("foo1.pdf")
plot(X, v, xlab="state space", ylab="value")
dev.off()

pdf("foo2.pdf")
plot(X, policy, xlab="state space", ylab="policy")
dev.off()
